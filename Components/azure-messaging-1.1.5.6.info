{"Name":"Azure Messaging","Id":1844,"Alias":"azure-messaging","Description":"\nWindows Azure Messaging with Xamarin.iOS and Xamarin.Android allows you to register your apps with Azure Notification Hubs.\n\n\nNotification Hubs provide a highly scalable, cross-platform push notification infrastructure that enables you to either broadcast push notifications to millions of users at once or tailor notifications to individual users.\n\nOn every mobile platform, push notifications are a critical element of any application. Push Notifications are simply the most immediate means through which to engage and empower your users. Building and maintaining the infrastructure for a push notification system capable of reaching millions of users within minutes, however, is far from simple. On your own, delivering millions of push notifications within minutes would require tens of virtual machines running in parallel. We created Notification Hubs to give developers an easy and reliable way to reach their users on any platform and from any connected application backend.\n\n### Getting the Samples to work\n\nIt\u0027s important to note that out of the box, these samples cannot just work.  You must first follow the steps for each specific platform in the **Getting Started** guide to setup an Azure Mobile Services instance, as Apple Push Notifications and/or Google Cloud messaging for your app, and configuring your Azure Mobile Services instance to work with each platform.  If you do not follow this setup, you will see `NotImplementedException` exceptions raised.\n\n###Broadcast cross-platform push notifications to millions of devices in minutes\n\nNotification Hubs supply a common API to send push notifications to a variety of mobile platforms, including Windows Store, Windows Phone, iOS and Android. You can choose to send platform-specific notifications or broadcast a single platform-agnostic notification to all users. A few lines of code gives you the power to reach either all devices on a single platform or all iOS, Android and Windows devices at once.\n\nNotification Hubs send out push notifications to millions of users within minutes, not hours. That makes this service a particularly good partner for when speed matters most—such as with breaking news.\n\n### Send notifications from any backend\n\nNotification Hubs can be used with any connected application—whether it’s built on Virtual Machines, Cloud Services, Web Sites, or Mobile Services. This makes it easy to update any of your mobile apps right away and start engaging your users on their terms.\n\n### Target content to specific user segments\n\nWith Notification Hubs, you not only have the ability to broadcast notifications to all your users at once (regardless of their mobile platform). You also have the ability to subscribe users to any number of tags when you register them with a Notification Hub. Those tags give you an easy way to define and target user segments based on activity, interests, location, etc. with a single API call. By using those tags effectively, you never have to store and mange device tokens or Ids in your app’s backend in order to route notifications to particular users.\n\n### Use templates to tailor each user’s notifications\n\nTemplates provide a way for developers to specify the exact format of the notification that each user receives based on each of their preferences. By using templates, there is no need to store the localization settings for each of your customers or to create hundreds of tags. You just need to register the templates that specify the correct language with a Notification Hub and send a single message with all the localized content. Once your Notification Hub receives that single message, it will extract the correct localized message for each targeted user from the message.\n\n### Achieve extreme scale\n\nNotification Hubs are optimized for massive scale. With Notification Hubs, you can quickly scale to millions of devices and billions of push notifications without ever having to re-architect or shard your application. The Notification Hub you configure for a given application will automatically handle the pub/sub scale-out infrastructure necessary to scale your message to every active device with incredibly low latency. All it takes is one message from your connect app’s backend to the Notification Hub and millions of push notifications will be fired off to your users.\n\nNotification Hubs are backed by a high availability service level agreement. To start sending push notifications to every user on every device, you will need an Azure account. Sign up for the free trial here.\n","Version":"1.1.5.6","Summary":"Send Push Notifications to your iOS and Android apps","QuickStart":"## Adding Windows Azure Messaging to your iOS and Android Apps\n\nThe Windows Azure Messaging SDK allows you to register your apps\u0027 devices with a Notification Hub in Azure.  \n\n\n### Getting the Samples to work\n\nIt\u0027s important to note that out of the box, these samples cannot just work.  You must first follow the steps for each specific platform to setup an Azure Mobile Services instance, as Apple Push Notifications and/or Google Cloud messaging for your app, and configuring your Azure Mobile Services instance to work with each platform.  If you do not follow this setup, you will see `NotImplementedException` exceptions raised.\n\n### iOS Setup\n\nIf you have not already done so, you need to setup your app and generate your Push certificate(s) on the Apple Developer portal, as well as create and/or configure a Notification Hub on Azure to use your push certificate(s).  You can follow the guide here: [Get started with Notification Hubs for Xamarin.iOS](http://azure.microsoft.com/en-us/documentation/articles/partner-xamarin-notification-hubs-ios-get-started/).  Only steps 1 through 4 are relevant to this component.\n\nWhen you are ready to connect your Xamarin.iOS app to the Notification Hub, you should add the following code to your `FinishedLaunching` override in your `AppDelegate`:\n\n```\npublic override bool FinishedLaunching (UIApplication app, NSDictionary options)\n{\n\t// Process any potential notification data from launch\n\tProcessNotification (options);\n\n\t// Register for Notifications\n\tUIApplication.SharedApplication.RegisterForRemoteNotificationTypes (\n\t\tUIRemoteNotificationType.Alert |\n\t\tUIRemoteNotificationType.Badge |\n\t\tUIRemoteNotificationType.Sound);\n\n\t// ...\n\t// Your other code here\n\t// ...\n}\n```\n\nYou should also override these other methods:\n\n```\npublic override void RegisteredForRemoteNotifications (UIApplication app, NSData deviceToken)\n{\n\t// Connection string from your azure dashboard\n\tvar cs = SBConnectionString.CreateListenAccess(\n\t\tnew NSUrl(\"sb://yourservicebus-ns.servicebus.windows.net/\"),\n\t\t\"YOUR-KEY\");\n\n\t// Register our info with Azure\n\tvar hub = new SBNotificationHub (cs, \"your-hub-name\");\n\thub.RegisterNativeAsync (deviceToken, null, err =\u003e {\n\t\tif (err != null)\n\t\t\tConsole.WriteLine(\"Error: \" + err.Description);\n\t\telse\n\t\t\tConsole.WriteLine(\"Success\");\n\t});\n}\n\npublic override void ReceivedRemoteNotification (UIApplication app, NSDictionary userInfo)\n{\n\t// Process a notification received while the app was already open\n\tProcessNotification (userInfo);\n}\n```\n\nNotice how in both `FinishedLaunching` and `ReceivedRemoteNotification` we call the method `ProcessNotification(NSDictionary userInfo)`.  This is because `ReceivedRemoteNotification` will only be called when a Push Notification is received and the app is already running/in the foreground.  When an app is launched because the user has acted on a notification, the `options` parameter in `FinishedLaunching` will contain the notification information instead.\n\n\n\n### Android Setup\n\nIf you haven\u0027t done so, you should create a Google Console project for your app and enable Google Cloud Messaging on it.  You can follow the guide here: [Get started with Notification Hubs for Xamarin.Android](http://azure.microsoft.com/en-us/documentation/articles/partner-xamarin-notification-hubs-android-get-started/).  Only steps 1 and 2 should be followed.\n\nWhen you are ready to connect you Xamarin.Android app to the Notification Hub, you should subclass `GcmServiceBase` and `GcmBroadcastReceiverBase\u003cTGcmServiceBase\u003e` in your application.  Note the methods for Initializing the `NotificationHub` and registering with Gcm in the sample.  Also note it\u0027s **VERY IMPORTANT** that your Application\u0027s package name must not start with an upper case letter, or you will receive a deploy error!\n\nYou should add the following permission to your app (you can just include this assembly level attribute, or add it to the Android Manifest):\n```csharp\n[assembly: UsesPermission (Android.Manifest.Permission.ReceiveBootCompleted)]\n```\n\nHere is an example implementation you can copy and paste and change to suit your needs:\n\n```csharp\n[BroadcastReceiver(Permission=Constants.PERMISSION_GCM_INTENTS)]\n[IntentFilter(new[] { Intent.ActionBootCompleted })] // Allow GCM on boot and when app is closed   \n[IntentFilter(new string[] { Constants.INTENT_FROM_GCM_MESSAGE },\n\tCategories = new string[] { \"@PACKAGE_NAME@\" })]\n[IntentFilter(new string[] { Constants.INTENT_FROM_GCM_REGISTRATION_CALLBACK },\n\tCategories = new string[] { \"@PACKAGE_NAME@\" })]\n[IntentFilter(new string[] { Constants.INTENT_FROM_GCM_LIBRARY_RETRY },\n\tCategories = new string[] { \"@PACKAGE_NAME@\" })]\npublic class SampleGcmBroadcastReceiver : GcmBroadcastReceiverBase\u003cSampleGcmService\u003e\n{\n\t//IMPORTANT: Change this to your own Sender ID!\n\t//The SENDER_ID is your Google API Console App Project Number\n\tpublic static string[] SENDER_IDS = { \"1234567890\" };\n}\n\n[Service] //Must use the service tag\npublic class SampleGcmService : GcmServiceBase\n{\n\tstatic NotificationHub hub;\n\n\tpublic static void Initialize(Context context)\n\t{\n\t\t// Call this from our main activity\n\t\tvar cs = ConnectionString.CreateUsingSharedAccessKeyWithListenAccess (\n\t\t\tnew Java.Net.URI (\"sb://yourservicebus-ns.servicebus.windows.net/\"),\n\t\t\t\"YOUR-KEY\");\n\n\t\tvar hubName = \"your-hub-name\";\n\n\t\thub = new NotificationHub (hubName, cs, context);\n\t}\n\n\tpublic static void Register(Context Context)\n\t{\n\t\t// Makes this easier to call from our Activity\n\t\tGcmClient.Register (Context, SampleGcmBroadcastReceiver.SENDER_IDS);\n\t}\n\n\tpublic SampleGcmService() : base(SampleGcmBroadcastReceiver.SENDER_IDS)\n\t{\n\t}\n\n\tprotected override void OnRegistered (Context context, string registrationId)\n\t{\n\t\t//Receive registration Id for sending GCM Push Notifications to\n\n\t\tif (hub != null)\n\t\t\thub.Register (registrationId, \"TEST\");\n\t}\n\n\tprotected override void OnUnRegistered (Context context, string registrationId)\n\t{\n\t\tif (hub != null)\n\t\t\thub.Unregister ();\n\t}\n\n\tprotected override void OnMessage (Context context, Intent intent)\n\t{\n\t\tConsole.WriteLine (\"Received Notification\");\n\n\t\t//Push Notification arrived - print out the keys/values\n\t\tif (intent != null || intent.Extras != null) {\n\n\t\t\tvar keyset = intent.Extras.KeySet ();\n\n\t\t\tforeach (var key in intent.Extras.KeySet())\n\t\t\t\tConsole.WriteLine (\"Key: {0}, Value: {1}\", key, intent.Extras.GetString(key));\n\t\t}\n\t}\n\n\tprotected override bool OnRecoverableError (Context context, string errorId)\n\t{\n\t\t//Some recoverable error happened\n\t\treturn true;\n\t}\n\n\tprotected override void OnError (Context context, string errorId)\n\t{\n\t\t//Some more serious error happened\n\t}\n}\n```\n\nFinally, in your application\u0027s main `Activity` you should Initialize the Hub and ensure your device is registered.  Adding this to the `OnCreate` override is a reasonable choice:\n\n```\nprotected override void OnCreate (Bundle bundle)\n{\n\tbase.OnCreate (bundle);\n\n\t// Set our view from the \"main\" layout resource\n\t\t\tSetContentView (Resource.Layout.Main);\n\n\t// Initialize our Gcm Service Hub\n\tSampleGcmService.Initialize (this);\n\n\t// Register for GCM\n\tSampleGcmService.Register (this);\n}\n```\n","Hash":"52ebc81dd6d933cbb9ab5570ada6d753","TargetPlatforms":["ios","ios-unified","android"],"TrialHash":null}